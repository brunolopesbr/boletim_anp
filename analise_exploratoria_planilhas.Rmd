---
title: 'Analise Exploratória: planilhas'
output: html_document
date: "2024-06-13"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(readxl)
library(xml2)
library(XML)
library(clock)

```


# Análise Exploratória: planilhas

Aqui vamos explorar a maneira com que os dados estão dispostos nas planilhas, guiando a maneira como esses dados serão retirados delas

## Número de planilhas

Os arquivos estão no diretório /data, e o elemento "planilhas" tem o nome de todas elas.

```{r}
planilhas <- dir(path = "data", pattern = "*xls*")
qtde_planilhas <- length(planilhas) 
```
São `r qtde_planilhas` planilhas.

## Funções personalizadas

Para usar o objeto "planilhas" em funções interativas, criei funções para importar para o R os dados que estão nas planilhas.

```{r}
excel_sheets_data <- function(x){
  excel_sheets(paste0("data/", x))
}
# range A1:J1000 garante que todos os dataframes são importados para o R com o mesmo tamanho, condição importante para a iteração de diferenntes fontes de dados

read_excel_data  <- function(x,sheet = 1, range = "A1:J1000", skip = 0){
  read_xlsx(paste0("data/", x), col_types = "text",
             sheet = sheet,
              range = range,
                skip = skip,
               col_names = FALSE,
               .name_repair = "unique_quiet",)
}
```

## Worksheets: quantidade e conteúdo

Toda planilha eletrônica contém ao menos uma worksheet (também chamado de aba). Vamos explorar o conteúdo de cada aba, começando pela primeira.

### Primeira worksheet

A primeira worksheet de cada planilha chama-se "Lista de Tabelas" e contém a informação do mês de referência e uma lista de tabelas. Entretanto, essa lista não foi escrita diretamente na planilha, mas em caixas de texto. Esse conteúdo não é importado diretamente pela função readxl, e é necessário realizar esses procedimentos:

1 - Renomear cada planilha como um arquivo .zip
2 - Descompactar o arquivo .zip, mostrando uma estrutura com diversos arquivos .xml
3 - Utilizando a estrutura padronizada utilizada nas planilhas, extrair a informação da data.

O detalhamento desse procedimento pode ser encontrado no arquivo "extrair_data.Rmd". Aqui será mostrada a função personalizada que retira a informação com a data da primeira worksheet de cada planilha.

!(img/worksheet_1.png)

### Função personalizada - extrair data

Criação de objeto com nomes dos arquivos

```{r}
planilhas <- dir(path = "data", pattern = "*xls*")

planilhas_zip <- planilhas

planilhas_zip <- planilhas_zip |> 
  str_replace_all(pattern = "xlsm", replacement = "zip")
```

Função personalizada:
```{r}
extrair_data <- function(num){
  
invisible(file.copy(from = paste0("data/", planilhas[num]), to = paste0("data/zip/", planilhas_zip[num]), overwrite = TRUE))

unzip(zipfile = paste0("data/zip/", planilhas_zip[num]), exdir = "data/zip", overwrite = TRUE)

xml_prov <- xmlParse("data/zip/xl/drawings/drawing1.xml") |> 
  xmlToDataFrame()

sheet1_data <- xml_prov[2,3] |> 
  str_remove_all("/.*") |> 
    str_trim() |> 
  str_remove_all("[:punct:]") |> 
  str_remove_all(" de")

mes_boletim <- paste0("01 ",sheet1_data)

mes_boletim

}
```

Exemplo: extração da data do arquivo expresso no primeiro item do elemento:

```{r}
planilhas[1]
```
```{r warning=FALSE}
extrair_data(1)
```
Iteração de todas as planilhas, usando a função map e criando uma lista

```{r warning=FALSE}
lista_datas <- map(1:length(planilhas), extrair_data)
```

Que em seguida pode ser transformada em um dataframe, para conferência.

Tabela 1:
```{r}
lista_datas2 <- do.call(rbind, lista_datas)

df_planilhas_datas <- data.frame(arquivos = planilhas,
           mes = as.data.frame(lista_datas2)) 

df_planilhas_datas <- df_planilhas_datas |> 
mutate(mes = year_month_day_parse(
  V1,
  format = "%d %B %Y",
  locale = clock_locale("pt")
)) |> 
  rename(mes_escrito = V1)

df_planilhas_datas
```
A tabela mostra a consistência entre o nome do arquivo e o mês da conta. Também mostra que falta o mês de fevereiro.

Não é uma prática amigável para o usuário escrever a data a que se refere o boletim em uma caixa de texto. Ter essa informação escrita em uma célula da planilha seria uma boa prática. Ao menos ela está escrita dentro do arquivo, já que o nome local do arquivo é criado pelo usuário, no momento em que faz a transferência.

### Worksheets 2 em diante

Nas worksheets 2 em diante estão as tabelas com os dados de produção, que são o principal objeto de atenção deste trabalho. Os dados estão como na figura abaixo: o nome "Tabela", seguido por uma numeração, uma linha em branco e os dados propriamente ditos.

Como se pode ver na imagem, o número de colunas varia conforme cada tabela. Ao longo dos anos algumas tabelas mudaram de nome ou de lugar, mas é possível fazer alguns agrupamento, utilizando uma busca pela palavra chave "tabela"

#### Worksheet 2

A worksheet 2 contém tabelas históricas. As três primeiras planilhas (outubro a dezembro de 2017) contém apenas três tabelas.

```{r}
arquivos_2017 <- 1:3

map_df(planilhas[arquivos_2017], read_excel_data, sheet = 2) |> 
  filter(if_any(2, ~ str_detect(., "Tabela"))) |> 
  distinct() |> 
  select(...2)
```

Para as outras planilhas a worksheet 2 contém quatro tabelas. Nas tabelas 4 a 7 percebe-se uma pequena inconsistência na nomenclatura, mas o título permite a inferência de que se tratam dos mesmos dados.

```{r}
map_df(planilhas[4], read_excel_data, sheet = 2) |> 
  filter(if_any(2, ~ str_detect(., "Tabela"))) |> 
  distinct() |> 
  select(...2)
```

```{r}
worksheet2_outras <- map_df(planilhas[8:20], read_excel_data, sheet = 2) 

worksheet2_outras |> 
  filter(if_any(2, ~ str_detect(., "Tabela"))) |> 
  distinct() |> 
  select(...2)
```

Portanto, essas são as tabelas que constam da worksheet 2:

```{r}
arquivos_2018_diante <- 4:length(planilhas)

map_df(planilhas[arquivos_2018_diante], read_excel_data, sheet = 2) |> 
  filter(if_any(2, ~ str_detect(., "Tabela"))) |>
  mutate(...2 = str_replace_all(...2, "MMm", "Mm"),
         ...2 = str_replace_all(...2, "m3", "m³")) |> 
  distinct() |> 
  select(...2)
```

#### Worksheet 3

A worksheet contém os dados disponibilizados mensalmente, e por isso os mais relevantes. Todas as worksheets de 2017 contém as mesmas tabelas de dados:

```{r}
map_df(planilhas[arquivos_2017], read_excel_data, sheet = 3) |> 
  filter(if_any(2, ~ str_detect(., "Tabela"))) |> 
  distinct() |> 
  select(...2)
```
Os arquivos de 2018 em diante têm as tabelas numeradas de 5 em diante (já que têm 4 tabelas na worksheet 2). Mas alguns desses arquivos possuem tabelas adicionais.
```{r}
map_df(planilhas[arquivos_2018_diante], read_excel_data, sheet = 3) |> 
  filter(if_any(2, ~ str_detect(., "Tabela"))) |> 
  distinct() |> 
  select(...2)
```
Com um for loop é possível verificar quais são os arquivos que tê uma tabela adicional na worksheet 4. 

```{r}
planilhas[33]
planilhas[57]

for(i in 33:57){
map_df(planilhas[i], read_excel_data, sheet = 3) |> 
  filter(if_any(2, ~ str_detect(., "Tabela"))) |> 
  distinct()  |> 
    print()
}

```
Possuem uma tabela adicional os arquivos numerados de 33 a 57 (de junho de 2020 a março de 2022).

```{r}
arquivos_tabela_adicional_ws3 <- 33:57

map_df(planilhas[arquivos_tabela_adicional_ws3], read_excel_data, sheet = 3) |> 
  filter(if_any(2, ~ str_detect(., "Tabela"))) |> 
  distinct()  |> 
    print() |> 
  select(...2)

```

As planilhas de 4 a 32 e 58 até xxx têm tabelas numeradas de 5 a 11 na worksheet 3.

```{r}
arquivos_sem_tabela_adicional_ws4 <- c(4:32, 58:77)
  
map_df(planilhas[arquivos_sem_tabela_adicional_ws4], read_excel_data, sheet = 3) |> 
  filter(if_any(2, ~ str_detect(., "Tabela"))) |> 
  distinct()  |> 
    print() |> 
  select(...2)
```

#### Worksheet 4

Usando os grupos estabelecidos anteriormente. Arquivos de 2017:

```{r}
map_df(planilhas[arquivos_2017], read_excel_data, sheet = 4) |> 
  filter(if_any(2, ~ str_detect(., "Tabela"))) |> 
  distinct()  |> 
    print() |> 
  select(...2)
```

Arquivos numerados de 4 a 32:

```{r}
map_df(planilhas[4:32], read_excel_data, sheet = 4) |> 
  filter(if_any(2, ~ str_detect(., "Tabela"))) |> 
  distinct()  |> 
    select(...2)
```

Arquivos com a tabela adicional:

```{r}
map_df(planilhas[arquivos_tabela_adicional_ws3], read_excel_data, sheet = 4) |> 
  filter(if_any(2, ~ str_detect(., "Tabela"))) |> 
  distinct()  |> 
  select(...2) 
```
Os arquivos numerados de 58 a 77:

```{r}
map_df(planilhas[58:77], read_excel_data, sheet = 4) |> 
  filter(if_any(2, ~ str_detect(., "Tabela"))) |> 
  distinct()  |> 
    select(...2)
```

CONCLUSÃO?????

#### Worksheet 5

Nem todos os arquivos têm a sheet 5. Foi uma ba criada para a época da Covid. Com a função excel_sheets podemos extrair o nome de todas as abas, e, consequentemente, identificar aquelas que têm essa informação sobre a Covid.

```{r}
lista_abas <- map(planilhas[1:length(planilhas)], excel_sheets_data)  

arquivos_covid <- do.call(rbind, lista_abas) |> 
  as.data.frame() |> 
  mutate(num_linhas = 1:length(planilhas)) |> 
  filter(str_detect(V5, "Covid")) |> 
  pull(num_linhas)

arquivos_covid

```


```{r}

map_df(planilhas[arquivos_covid], read_excel_data, sheet = 5) |> 
  filter(if_any(2, ~ str_detect(., "Tabela"))) |> 
  distinct()  |> 
      select(...2)
```

